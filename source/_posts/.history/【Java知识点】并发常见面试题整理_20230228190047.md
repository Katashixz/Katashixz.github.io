---
title: 【Java知识点】关于并发的一些面试问答
date: 2023-02-28 14:47:10
categories: 自主学习
cover: ../image/IO/IO.jpg
---

本篇文章内容参考[JavaGuide](https://javaguide.cn/)，自己整理一遍加深印象。

# 并发知识点的一些基础概念

## 进程与线程的定义

- 进程
  - 程序的一次执行过程，是系统运行程序的基本单位，进程是动态的。
- 线程
  - 比进程更小的执行单位
  - 一个进程执行过程中可以产生多个线程
  - 同类的多个线程共享进程的**堆和方法区资源**
  - 每个线程有自己的**程序计数器、虚拟机栈和本地方法栈**
  - 也被称为轻量级进程

## 程序计数器为什么是私有的

一句话概括——为了让线程切换后能够恢复到正确的执行位置

##  堆和方法区的作用

- 是所有线程共享的资源
- 堆
  - 进程中最大的一块内存
  - 存放新创建的对象(几乎所有对象都是在这里分配内存)
- 方法区
  - 存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

## 并发和并行的区别

- 并发：两个及两个以上的作业在同一**时间段**内执行
- 并行：两个及两个以上的作业在同一**时刻**执行

## 同步和异步的区别

- 同步： 发出一个调用之后，在没有得到结果之前，该调用就不可以返回，一直等待。
- 异步： 调用发出之后，不用等待返回结果，该调用直接返回。

## 线程的生命周期和状态

- NEW：初始状态，线程被创建出来，但是没有被调用start()
- RUNNABLE：运行状态，线程被调用了start()等待运行的状态
- BLOCKED：阻塞状态，需要等待锁释放
- WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作(通知或中断)
- TIME_WAITING：超时等待状态，可以再指定的时间后自行返回而不是像WAITING那样一直等待。
- TERMINATED：终止状态，表示该线程已经运行完毕。

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

![](../image//%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/lifeOfThread.png)

## 什么是上下文切换？

线程在执行过程中都会有自己的运行条件和状态(也称为上下文)，比如上文所说道过的程序计数器，栈信息等。当出现如下情况的时候，线程会从CPU状态中退出。
- 主动让出CPU，比如调用了`sleep()`,`wait()`等
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死
- 被调用了阻塞类型的系统中断，比如请求IO，线程被阻塞
- 被终止或结束运行

这其中前三种都会发生线程切换，发生线程切换意味着要保存当前线程的上下文，以便其下次占用CPU的时候恢复现场，并加载下一个将要占用CPU的线程上下文。这就是**上下文切换**。频繁的切换会造成整体效率低下，因为要占用CPU、内存等资源来保存和恢复信息。

## 什么是线程死锁？如何避免死锁？

## sleep()和wait()方法对比

- 共同点
  - 两者都可以暂停线程的执行
- 不同点
  - sleep()方法没有释放锁，而wait()方法释放了锁。
  - wait()方法通常被用于线程间交互/通信，sleep()通常被用于暂停执行。
  - wait()方法被调用后，线程不会自动苏醒，通常需要别的线程调用同一个对象上的notify()或者notifyAll()方法，sleep()方法执行完成后，线程会自动苏醒，或者也可以使用wait(long timeout)超时后线程会自动苏醒。
  - sleep()是Thread类的静态本地方法，wait()则是Object类的本地方法。

## 为什么wait()方法不定义在Thread中？

`wait()`是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象(`Object`)都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象(`Object`)而非当前的线程(`Thread`)。

## 可以直接调用Thread类的run方法吗？（常问）

一句话概括——调用`start()`方法可以启动线程并使线程进入就绪状态，直接执行`run()`方法的话不会以多线程的方式执行。

详解——new 一个`Thread`，线程进入了新建状态。调用`start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。`start()`会执行线程的相应准备工作，然后自动执行`run()`方法的内容，这是真正的多线程工作。 但是，直接执行`run()`方法，会把`run()`方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。



